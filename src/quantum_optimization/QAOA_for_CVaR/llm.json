{
  "task": "qaoa_cvar_portfolio_optimization_single_fit_unique_sets_backtest",

  "intent": {
    "problem": "Repeated re-optimization (rolling/periodic) is too expensive and confounds evaluation when comparing quantum vs classical tools.",
    "goal": "Detect unique portfolio asset combinations, run QAOA optimization exactly once per unique asset-set (and per hyperparameter/weight config if enabled), then backtest those fixed weights over historical data without any re-optimization."
  },

  "inputs": {
    "panel_price_path": "data/processed/panel_price.parquet",
    "baseline_portfolios_path": "portfolios/portfolios.parquet",

    "scenario_source": {
      "type": "historical",
      "historical_returns_path": null,
      "qgan_scenarios_path": null,
      "notes": "Single in-sample scenario set per unique asset-set using a fixed training window; no rolling scenario refresh."
    },

    "return_type": "log",
    "loss_definition": "negative_return",
    "confidence_levels": [0.95, 0.99],
    "risk_free_rate": 0.0001,
    "total_asset_universe_size": 10
  },

  "max_unique_asset_sets": null,
  "fast_mode": true,

  "unique_portfolio_handling": {
    "enabled": true,
    "unique_key": "asset_set",
    "asset_set_definition": {
      "type": "sorted_asset_ids",
      "notes": "Two portfolios are identical if they contain the same asset ids, regardless of ordering."
    },
    "deduplicate_baseline_portfolios": true,
    "persist_unique_asset_sets": true
  },

  "single_fit_protocol": {
    "enabled": true,

    "train_test_split": {
      "type": "date_based",
      "train": {
        "start_date": "AUTO_FROM_DATA_START",
        "end_date": "AUTO_TRAIN_END_DATE"
      },
      "test": {
        "start_date": "AUTO_TEST_START_DATE",
        "end_date": "AUTO_FROM_DATA_END"
      },
      "default_rule_if_not_overridden": {
        "train_years": 3,
        "test_years": "rest_of_data",
        "notes": "Use first N years as in-sample; apply optimized fixed weights on remaining period."
      }
    },

    "rebalance_policy": {
      "type": "fixed_weights_no_reopt",
      "rebalance_frequency": "none",
      "notes": "Weights are computed once and held constant throughout the entire test period. No rolling, no periodic re-optimization."
    },

    "transaction_costs": {
      "enabled": false,
      "model": "proportional",
      "one_way_cost_bps": 5,
      "notes": "If enabled, only initial implementation turnover is charged (since there is no rebalancing)."
    }
  },

  "execution_plan": {
    "stage_A_build_unique_asset_sets": true,
    "stage_B_single_in_sample_qaoa_optimize_per_asset_set": true,
    "stage_C_backtest_fixed_weights_on_test_period": true,

    "key_idea": {
      "optimize_once_per_unique_asset_set": true,
      "reuse_hamiltonian_and_scenarios_per_asset_set": true,
      "evaluate_full_test_history_without_reoptimization": true
    }
  },

  "precompute_registry": {
    "enabled": true,
    "persist_to_disk": true,
    "registry_root": "cache/qaoa_cvar_single_fit",
    "format": {
      "tabular": "parquet",
      "arrays": "npy",
      "quantum_objects": "pickle"
    },

    "artifacts": {
      "daily_returns_full_universe": "cache/qaoa_cvar_single_fit/daily_returns_full.parquet",

      "unique_asset_sets": "cache/qaoa_cvar_single_fit/unique_asset_sets.parquet",
      "portfolio_to_asset_set_map": "cache/qaoa_cvar_single_fit/portfolio_asset_set_map.parquet",

      "train_scenario_matrix_by_asset_set": "cache/qaoa_cvar_single_fit/train_scenarios_by_asset_set.npz",
      "train_loss_coeffs_by_asset_set": "cache/qaoa_cvar_single_fit/train_loss_coeffs_by_asset_set.npz",

      "cost_hamiltonian_by_asset_set": "cache/qaoa_cvar_single_fit/cost_h_by_asset_set.pkl",
      "mixer_hamiltonian": "cache/qaoa_cvar_single_fit/mixer_h.pkl",

      "qaoa_best_params_by_asset_set": "cache/qaoa_cvar_single_fit/qaoa_best_params.parquet",
      "qaoa_samples_by_asset_set": "cache/qaoa_cvar_single_fit/qaoa_samples.parquet"
    },

    "reuse_rules": {
      "scenario_generation": {
        "cache_key": ["asset_set", "train_start_date", "train_end_date", "scenario_count", "scenario_source"],
        "compute_once": true
      },
      "loss_coefficients": {
        "cache_key": ["asset_set", "confidence_level", "alpha_tail", "loss_definition", "train_window_hash"],
        "compute_once": true
      },
      "hamiltonian_construction": {
        "cache_key": ["asset_set", "objective_weights", "constraints_hash", "train_window_hash"],
        "compute_once": true
      },
      "qaoa_optimization": {
        "cache_key": ["asset_set", "reps", "optimizer", "shots", "seed"],
        "compute_once": true
      }
    }
  },

  "portfolio_problem": {
    "decision_variables": {
      "type": "binary_selection",
      "variable": "x_i",
      "meaning": "x_i = 1 if asset i is selected, else 0"
    },

    "portfolio_weighting": {
      "type": "equal_weight_on_selected",
      "notes": "QAOA selects assets. Final weights are fixed as 1/K for selected assets (K = number selected). Optional extension: discretized weights with extra qubits (not used here)."
    },

    "constraints": {
      "cardinality": {
        "enabled": true,
        "target_k": [5, 10],
        "penalty_weight": 10.0
      },
      "long_only": true,
      "fully_invested": true,
      "max_weight_per_asset": 0.25,
      "sector_or_group_constraints": {
        "enabled": false
      }
    }
  },

  "cvar_objective": {
    "enabled": true,
    "formulation": "scenario_based_cvar",
    "alpha_tail": 0.95,
    "definition": "CVaR_alpha = mean of worst (1-alpha) fraction of portfolio loss across TRAIN scenarios",

    "scenario_loss_model": {
      "loss_per_scenario": "L_s(x) = - sum_i (r_{s,i} * w_i(x))",
      "weights_from_selection": "w_i(x) = x_i / sum_j x_j",
      "linearization": {
        "enabled": true,
        "method": "auxiliary_variables",
        "notes": "If linearization becomes too large, fallback to a quadratic tail-risk proxy for QUBO feasibility."
      }
    },

    "objective_weights": {
      "risk_weight": [1.0, 2.0],
      "return_weight": [0.25, 0.75],
      "diversification_weight": [0.1, 0.5]
    }
  },

  "qubo_construction": {
    "formulation": "ising_from_multiobjective_qubo",
    "normalization": {
      "enabled": true,
      "method": "zscore_across_assets_on_train"
    },

    "components": {
      "risk_term": "cvar_proxy_or_linearized_cvar_on_train",
      "return_term": "maximize_mean_return_on_train",
      "diversification_term": "correlation_penalty_on_train",
      "constraint_penalties": ["cardinality_penalty", "budget_penalty"]
    },

    "penalty_weights": {
      "budget_penalty": 10.0,
      "cardinality_penalty": 10.0,
      "linearization_penalty": 15.0
    }
  },

  "qaoa_settings": {
    "ansatz": {
      "type": "qaoa",
      "reps_grid": [1, 2, 3],
      "initial_point": "zeros"
    },

    "optimizer": {
      "type": "cobyla",
      "maxiter": 250,
      "tol": 0.0001,
      "seed": 42
    },

    "execution": {
      "backend": "aer_simulator",
      "shots": 5000,
      "parameterized_circuit_reuse": true,
      "measurement_error_mitigation": false
    },

    "cvar_sampling": {
      "enabled": true,
      "definition": "Optimize using CVaR of measured bitstring energies (tail-average of energies).",
      "alpha_grid": [0.95, 0.99],
      "notes": "This is QAOA-CVaR objective on Hamiltonian energies; financial CVaR is evaluated separately on realized returns in the test period."
    },

    "stopping_criteria": {
      "patience": 25,
      "min_improvement": 0.0001
    }
  },

  "multi_objective_analysis": {
    "enabled": true,
    "pareto_front": {
      "tracking": true,
      "metrics": ["expected_return_train", "cvar_train", "diversification_score_train", "constraint_violation_rate"]
    },

    "weight_sweep": {
      "enabled": true,
      "num_weight_configs": 12,
      "notes": "Even with weight sweep enabled, optimization is still performed once per (unique asset_set, weight_config). No date-based re-optimization."
    }
  },

  "batch_evaluation": {
    "enabled": true,

    "candidate_selection": {
      "top_n_by_energy": 200,
      "deduplicate_bitstrings": true,
      "ensure_constraint_satisfaction": true
    },

    "metrics_batching": {
      "compute_metrics_vectorized": true,
      "evaluate_oos": true,
      "time_sliced_metrics": {
        "enabled": true,
        "time_unit": "calendar_year",
        "store_long_format": true
      }
    }
  },

  "gpu_acceleration": {
    "enabled": true,
    "library": "cupy",
    "fallback_to_cpu": true,

    "use_for": ["train_scenario_loss_matrix_compute", "batch_candidate_scoring", "batch_quantiles_for_cvar"],
    "do_not_use_gpu_for": ["quantum_simulation", "optimizer_inner_loop"]
  },

  "parallelization": {
    "enabled": true,
    "strategy": "parallelize_over_unique_asset_sets_then_over_weight_configs",
    "n_jobs": "auto"
  },

  "evaluation": {
    "scope": "portfolio_level",
    "fit_scope": "train_only_once_per_unique_asset_set",

    "out_of_sample_performance": {
      "enabled": true,
      "metrics": [
        "realized_return",
        "realized_volatility",
        "realized_cvar",
        "max_drawdown",
        "sharpe_ratio",
        "turnover"
      ],
      "notes": "Turnover is computed only at initial implementation (train->test start) since there is no rebalancing."
    },

    "benchmark_comparison": {
      "enabled": true,
      "benchmarks": ["equal_weight", "mean_variance_classical", "cvar_optimization_classical"]
    }
  },

  "metrics": {
    "optimization_quality": ["best_energy", "energy_gap", "constraint_violation_rate", "pareto_front_size"],

    "portfolio_performance_oos": ["realized_return", "realized_volatility", "realized_cvar", "max_drawdown", "sharpe_ratio"],

    "quantum_specific": ["reps", "shots", "num_qubits", "circuit_depth", "circuit_width", "nfev", "best_parameters"],

    "runtime": ["total_runtime_ms", "mean_qaoa_optimize_time_ms", "p95_qaoa_optimize_time_ms", "cache_hit_ratio"]
  },

  "outputs": {
    "unique_asset_sets": "results/quantum_optimization/qaoa_single_fit_unique_asset_sets.parquet",
    "qaoa_selected_portfolios": "results/quantum_optimization/qaoa_single_fit_selected_portfolios.parquet",
    "qaoa_samples": "results/quantum_optimization/qaoa_single_fit_samples.parquet",
    "portfolio_weights_fixed": "results/quantum_optimization/qaoa_single_fit_portfolio_weights.parquet",

    "portfolio_performance_train": "results/quantum_optimization/qaoa_single_fit_performance_train.parquet",
    "portfolio_performance_test": "results/quantum_optimization/qaoa_single_fit_performance_test.parquet",

    "pareto_front": "results/quantum_optimization/qaoa_single_fit_pareto_front.parquet",
    "metrics_table": "results/quantum_optimization/qaoa_single_fit_metrics.parquet",
    "time_sliced_metrics": "results/quantum_optimization/qaoa_single_fit_time_sliced_metrics.parquet",

    "metrics_schema_json": "results/quantum_optimization/qaoa_single_fit_metrics_schema.json",
    "summary_report": "results/quantum_optimization/qaoa_single_fit_result_summary.md",
    "runtime_profile": "results/quantum_optimization/qaoa_single_fit_runtime_profile.json"
  },

  "cursor_implementation_tasks": [
    {
      "file": "main.py",
      "changes": [
        "Stage A: Deduplicate baseline portfolios into unique asset sets; persist unique_asset_sets + portfolio->asset_set map.",
        "Build a single TRAIN window per asset set; generate TRAIN scenarios once and persist.",
        "Construct QUBO/Ising Hamiltonian once per (asset_set, weight_config, constraints_hash, train_window_hash).",
        "Run QAOA once per (asset_set, weight_config) across reps_grid; store best params + samples.",
        "Convert best feasible bitstrings to fixed weights (equal-weight on selected assets).",
        "Backtest fixed weights on the TEST window with no re-optimization and (optionally) no rebalancing.",
        "Compute train vs test tables, metrics, time-sliced metrics; write runtime profile."
      ]
    },
    {
      "file": "qaoa_portfolio.py",
      "changes": [
        "Implement unique asset-set hashing and consistent asset ordering for bitstring mapping.",
        "Implement cost construction based on TRAIN data only (return/diversification/CVaR proxy/constraints).",
        "Expose QUBO->Ising converter and caching keyed by (asset_set_hash, weight_config_id, constraints_hash, train_window_hash).",
        "Implement QAOA-CVaR objective on measured energies."
      ]
    },
    {
      "file": "metrics.py",
      "changes": [
        "Compute realized portfolio returns for TEST period using fixed weights.",
        "Compute realized CVaR (financial) on TEST returns at requested confidence levels.",
        "Compute drawdown, volatility, Sharpe; turnover only at initial implementation.",
        "Add time-sliced aggregation (yearly) for TEST performance."
      ]
    }
  ]
}
