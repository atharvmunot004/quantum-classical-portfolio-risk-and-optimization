{
  "task": "monte_carlo_var_cvar_asset_level_evaluation_optimized",

  "design_principle": {
    "mcs_scope": "asset_level_only",
    "portfolio_projection": false,
    "rationale": "Monte Carlo simulation is performed strictly per asset return series to generate VaR/CVaR forecasts under alternative data-generating assumptions (historical bootstrap, parametric Normal, parametric Student-t, and optional volatility-filtered simulation). Forecasts are produced as rolling time series using rolling estimation windows. VaR/CVaR are computed per asset for multiple confidence levels and horizons. Backtesting, tail diagnostics, distribution diagnostics, and time-sliced evaluation (year/quarter/month) are computed per asset without portfolio aggregation assumptions."
  },

  "inputs": {
    "panel_price_path": "data/preprocessed/panel_price.parquet",
    "asset_universe": {
      "mode": "from_columns",
      "include": null,
      "exclude": null
    }
  },

  "data_settings": {
    "return_type": "log",
    "tail_side": "left",
    "calendar": {
      "sort_index": true,
      "drop_duplicate_dates": true,
      "timezone": null
    },
    "missing_data_policy": {
      "dropna": "per_asset",
      "min_required_observations": 800
    }
  },

  "monte_carlo_settings": {
    "simulation_family": "returns_based",
    "methods": [
      {
        "name": "historical_bootstrap",
        "enabled": true,
        "bootstrap_type": "iid",
        "block_bootstrap": {
          "enabled": false,
          "block_length": 5,
          "note": "Enable to preserve short-range dependence; block_length typically 5-20 for daily data."
        },
        "center_and_scale": {
          "enabled": false,
          "center_rule": "subtract_mean",
          "scale_rule": "divide_by_std",
          "note": "Optional: standardize in-window returns, resample standardized shocks, then re-scale by in-window mean/std or filtered sigma."
        }
      },
      {
        "name": "parametric_normal",
        "enabled": true,
        "fit": {
          "mu": "sample_mean",
          "sigma": "sample_std"
        }
      },
      {
        "name": "parametric_student_t",
        "enabled": true,
        "fit": {
          "mu": "sample_mean",
          "sigma": "sample_std",
          "df": {
            "mode": "mle_or_fixed",
            "fixed_df": 5,
            "bounds": [2.1, 50.0],
            "fallback_df": 5
          }
        }
      },
      {
        "name": "filtered_ewma_bootstrap",
        "enabled": false,
        "filter": {
          "type": "ewma",
          "lambda": 0.94,
          "min_variance_floor": 1e-12
        },
        "shock_resampling": {
          "source": "standardized_residuals",
          "bootstrap_type": "iid",
          "block_bootstrap": {
            "enabled": false,
            "block_length": 5
          }
        },
        "reconstruction": {
          "use_next_sigma_forecast": true,
          "mu_rule": "zero_or_sample_mean",
          "note": "Compute standardized residuals e_t = r_t / sigma_t; resample e_t; simulate r_{t+1} = mu + sigma_{t+1} * e*."
        }
      }
    ],

    "estimation_windows": [252, 500],

    "rolling": {
      "enabled": true,
      "step_size": 1,
      "warmup_policy": "skip_until_window_full",
      "forecast_method": "rolling",
      "forecast_target": "one_step_ahead"
    },

    "confidence_levels": [0.95, 0.99],

    "horizons": {
      "base_horizon": 1,
      "scaled_horizons": [10],
      "horizon_handling": "path_simulation",
      "note": "For multi-day horizons, simulate return paths and compute VaR/CVaR on aggregated horizon return (sum of daily simulated returns). Avoid sqrt-time unless explicitly benchmarking."
    },

    "num_simulations": 20000,
    "path_aggregation_rule": "sum",
    "random_seed": 42,

    "risk_measure_definition": {
      "var_definition": "positive_loss_number",
      "cvar_definition": "expected_shortfall_positive_loss_number",
      "loss_transform": "loss = -return",
      "tail_side": "left",
      "notes": "For left-tail risk, define loss_t = -r_t. VaR is the alpha-quantile of loss. CVaR is the mean loss exceeding VaR."
    }
  },

  "computation_strategy": {
    "compute_daily_returns_once": true,

    "rolling_engine": {
      "vectorization": "per_asset_loop",
      "parallelization_axis": ["asset"],
      "max_workers": "auto",
      "chunk_assets": 1
    },

    "cache": {
      "enabled": true,
      "scope": "per_asset_per_method_per_window_per_time_index",
      "store_format": "parquet",

      "fitted_params_store_path": "cache/mcs_asset_fitted_parameters.parquet",
      "risk_series_store_path": "cache/mcs_asset_var_cvar_series.parquet",
      "simulation_meta_store_path": "cache/mcs_asset_simulation_metadata.parquet",

      "key_fields": [
        "asset",
        "date",
        "method",
        "estimation_window",
        "confidence_level",
        "horizon",
        "tail_side",
        "return_type",
        "num_simulations",
        "random_seed"
      ],

      "write_mode": "append_or_upsert",
      "cache_hit_ratio_metric": true
    },

    "runtime_instrumentation": {
      "enabled": true,
      "measure": [
        "total_runtime_ms",
        "returns_compute_time_ms",
        "window_fit_time_ms",
        "simulation_time_ms",
        "var_compute_time_ms",
        "cvar_compute_time_ms",
        "backtesting_time_ms",
        "time_slicing_time_ms"
      ]
    },

    "safety_checks": {
      "enabled": true,
      "checks": [
        {
          "name": "finite_returns_window",
          "rule": "all(isfinite(returns_window))",
          "on_fail": "skip_timestamp"
        },
        {
          "name": "sufficient_window_variation",
          "rule": "std(returns_window) > 0",
          "on_fail": "fallback_to_small_variance_floor"
        },
        {
          "name": "var_positive",
          "rule": "VaR > 0",
          "on_fail": "flag_and_continue"
        },
        {
          "name": "cvar_ge_var",
          "rule": "CVaR >= VaR",
          "on_fail": "flag_and_continue"
        },
        {
          "name": "expected_hit_rate_sanity",
          "rule": "abs(hit_rate - (1 - confidence_level)) <= 5 * (1 - confidence_level)",
          "on_fail": "flag_and_continue"
        }
      ]
    }
  },

  "evaluation": {
    "scope": "per_asset",
    "outputs_granularity": {
      "series_level": true,
      "summary_level": true,
      "time_sliced_level": true
    },

    "backtesting": {
      "enabled": true,
      "tests": [
        "hit_rate",
        "violation_ratio",
        "kupiec_unconditional_coverage",
        "christoffersen_independence",
        "christoffersen_conditional_coverage",
        "traffic_light_zone"
      ],
      "notes": "Backtesting is performed on aligned (returns, VaR, CVaR) time series per asset-method. Violations are defined for left-tail risk: loss_t = -return_t; violation if loss_t > VaR_t."
    },

    "time_sliced_metrics": {
      "enabled": true,
      "slice_by": ["year", "quarter", "month"],
      "minimum_observations_per_slice": 60,
      "metrics": [
        "hit_rate",
        "num_violations",
        "expected_violations",
        "violation_ratio",
        "cvar_hit_rate",
        "cvar_num_violations"
      ]
    }
  },

  "metrics": {
    "accuracy": [
      "hit_rate",
      "violation_ratio",
      "num_violations",
      "total_observations",
      "expected_violations",
      "kupiec_unconditional_coverage",
      "kupiec_test_statistic",
      "kupiec_reject_null",
      "christoffersen_independence",
      "christoffersen_independence_statistic",
      "christoffersen_independence_reject_null",
      "christoffersen_conditional_coverage",
      "christoffersen_conditional_coverage_statistic",
      "christoffersen_conditional_coverage_reject_null",
      "traffic_light_zone"
    ],

    "tail_behavior_var": [
      "mean_exceedance",
      "max_exceedance",
      "std_exceedance",
      "quantile_loss_score",
      "rmse_var_vs_losses"
    ],

    "tail_behavior_cvar": [
      "cvar_mean_exceedance",
      "cvar_max_exceedance",
      "cvar_std_exceedance",
      "rmse_cvar_vs_losses"
    ],

    "simulation_specific": [
      "method",
      "num_simulations",
      "seed",
      "window_mu",
      "window_sigma",
      "student_t_df",
      "ewma_lambda",
      "effective_sample_size",
      "fit_success",
      "convergence_flag"
    ],

    "distribution": [
      "skewness",
      "kurtosis",
      "jarque_bera_p_value",
      "jarque_bera_statistic"
    ],

    "runtime": [
      "total_runtime_ms",
      "runtime_per_asset_ms",
      "p95_runtime_ms",
      "mean_runtime_ms",
      "median_runtime_ms",
      "min_runtime_ms",
      "max_runtime_ms",
      "window_fit_time_ms",
      "simulation_time_ms",
      "cache_hit_ratio"
    ]
  },

  "outputs": {
    "fitted_parameter_store": {
      "path": "cache/mcs_asset_fitted_parameters.parquet",
      "contents": [
        "asset",
        "date",
        "method",
        "estimation_window",
        "window_mu",
        "window_sigma",
        "student_t_df",
        "ewma_lambda",
        "effective_sample_size",
        "fit_success",
        "convergence_flag"
      ],
      "notes": "Per rolling timestamp and method: stores fitted param summaries (or filter settings) used to generate simulations."
    },

    "risk_series_store": {
      "path": "results/classical_risk/mcs_asset_var_cvar_series.parquet",
      "format": "parquet",
      "contents": [
        "asset",
        "date",
        "method",
        "confidence_level",
        "horizon",
        "estimation_window",
        "VaR",
        "CVaR"
      ]
    },

    "metrics_table": {
      "path": "results/classical_risk/mcs_asset_level_metrics.parquet",
      "format": "parquet",
      "row_granularity": "asset_x_method_x_confidence_x_horizon_x_window",
      "notes": "Aggregated metrics over the full backtest period per asset, Monte Carlo method, and configuration."
    },

    "time_sliced_metrics_table": {
      "path": "results/classical_risk/mcs_asset_level_time_sliced_metrics.parquet",
      "format": "parquet",
      "row_granularity": "asset_x_method_x_slice_type_x_slice_value_x_confidence_x_horizon_x_window"
    },

    "mcs_results_scheme.json": {
      "path": "results/classical_risk/mcs_asset_level_results_scheme.json",
      "format": "json",
      "contents": "the scheme of the results, all the .parquet files"
    },

    "report": {
      "path": "results/classical_risk/mcs_asset_level_report.md",
      "include_sections": [
        "methodology_overview",
        "monte_carlo_methods_and_assumptions",
        "rolling_forecast_construction",
        "path_simulation_for_multi_horizon",
        "var_cvar_construction",
        "backtesting_results",
        "time_sliced_backtesting",
        "tail_risk_behavior",
        "distributional_characteristics",
        "computational_performance",
        "key_insights"
      ]
    }
  },

  "paper_usage_notes": {
    "simulation_phase": "Use this configuration for large-scale asset-level evaluation across historical bootstrap vs parametric simulation (Normal, Student-t) and optional filtered simulation. Report method-wise differences in coverage tests and tail exceedance behavior, highlighting when parametric assumptions under/over-estimate extreme losses.",
    "paper_phase": "For figures/tables: show (i) VaR/CVaR time series for representative assets, (ii) coverage + independence tests by method and confidence, (iii) time-sliced performance during stress regimes, and (iv) runtime scaling with number of simulations."
  }
}
