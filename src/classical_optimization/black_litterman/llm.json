{
  "task": "black_litterman_optimization_ultra_fast_precompute_gpu",

  "intent": {
    "problem": "Per-portfolio runtime ~40s is too slow for 100K portfolios",
    "goal": "Reduce total runtime by precomputing reusable Black-Litterman artifacts per unique asset-set and by vectorizing portfolio evaluation; optionally use GPU for large batch matrix ops; preserve metric accuracy."
  },

  "inputs": {
    "panel_price_path": "data/processed/panel_price.parquet",
    "baseline_portfolios_path": "portfolios/portfolios.parquet",
    "investor_views_path": "views/investor_views.json",
    "return_type": "log",
    "risk_free_rate": 0.0001,
    "total_asset_universe_size": 10
  },

  "execution_plan": {
    "stage_A_precompute_per_unique_asset_set": true,
    "stage_B_expand_weights_to_full_universe": true,
    "stage_C_batch_evaluate_all_portfolios": true,

    "key_idea": {
      "group_by_asset_set": true,
      "max_unique_asset_sets_if_10_assets": 1023,
      "compute_BL_once_per_asset_set": true,
      "compute_optimal_weights_once_per_asset_set": true,
      "reuse_for_all_portfolios_in_that_asset_set": true
    }
  },

  "precompute_registry": {
    "enabled": true,
    "persist_to_disk": true,
    "registry_root": "cache/bl_precompute",
    "format": {
      "tabular": "parquet",
      "arrays": "npy"
    },

    "artifacts": {
      "daily_returns_full_universe": "cache/bl_precompute/daily_returns_full.parquet",

      "asset_set_index": "cache/bl_precompute/asset_sets.parquet",
      "portfolio_to_asset_set_map": "cache/bl_precompute/portfolio_asset_set_map.parquet",

      "covariance_by_asset_set": "cache/bl_precompute/cov_by_asset_set.parquet",
      "market_equilibrium_by_asset_set": "cache/bl_precompute/prior_pi_by_asset_set.parquet",
      "market_weights_by_asset_set": "cache/bl_precompute/market_w_by_asset_set.parquet",

      "views_hash_by_asset_set": "cache/bl_precompute/views_hash_by_asset_set.parquet",
      "parsed_views_by_asset_set": "cache/bl_precompute/parsed_views_by_asset_set.npz",

      "posterior_returns_by_asset_set": "cache/bl_precompute/post_mu_by_asset_set.parquet",
      "posterior_cov_by_asset_set": "cache/bl_precompute/post_cov_by_asset_set.parquet",

      "optimal_weights_by_asset_set": "cache/bl_precompute/optimal_w_by_asset_set.parquet",

      "full_universe_weight_matrix_100k": "cache/bl_precompute/W_full_10x100k.npy"
    },

    "reuse_rules": {
      "covariance": {
        "cache_key": ["asset_set", "estimation_window", "shrinkage_method"],
        "compute_once": true
      },
      "market_equilibrium_pi": {
        "cache_key": ["asset_set", "risk_aversion", "market_weight_source"],
        "compute_once": true
      },
      "views_parsing_P_Q_Omega": {
        "cache_key": ["asset_set", "views_hash", "tau", "uncertainty_matrix_method"],
        "compute_once": true
      },
      "posterior_mu_and_cov": {
        "cache_key": ["asset_set", "views_hash", "tau"],
        "compute_once": true
      },
      "optimization": {
        "cache_key": ["asset_set", "objective", "constraints_hash", "solver_method"],
        "compute_once": true
      }
    }
  },

  "black_litterman_settings": {
    "risk_aversion": 2.5,
    "tau": 0.025,

    "covariance_estimation": {
      "method": "sample",
      "estimation_window": 252,
      "shrinkage": {
        "use_shrinkage": true,
        "method": "ledoit_wolf"
      }
    },

    "market_equilibrium": {
      "derive_pi_from_portfolios": true,
      "market_weight_source": "baseline_portfolios"
    },

    "views": {
      "use_external_views": true,
      "uncertainty_matrix": "idzorek",
      "confidence_levels": [0.5, 0.75, 0.9],
      "view_type": "absolute_relative_mixed",
      "num_views": 5
    },

    "posterior_settings": {
      "posterior_covariance_method": "black_litterman"
    }
  },

  "optimization": {
    "objective": "mean_variance",
    "risk_aversion": 1.0,

    "constraints": {
      "long_only": true,
      "fully_invested": true,
      "weight_bounds": [0.0, 1.0],
      "max_weight_per_asset": 0.25
    },

    "solver": {
      "method": "closed_form_preferred",
      "use_closed_form_when_possible": true,
      "fallback": "osqp",
      "tolerance": 1e-6,

      "cvxpy_reuse": {
        "enabled": true,
        "reuse_by_asset_set": true,
        "parameterize_mu_and_cov": true,
        "note": "Only used if closed_form is not feasible due to constraints."
      }
    }
  },

  "batch_evaluation": {
    "enabled": true,

    "portfolio_returns_matrix": {
      "compute_in_batch": true,
      "method": "matrix_multiply",
      "shape": "T x N",
      "use_full_universe_returns": true,
      "use_full_universe_weight_matrix": true
    },

    "metrics_batching": {
      "compute_metrics_vectorized": true,

      "accurate_metrics_no_sampling": true,
      "max_drawdown_vectorized": true,
      "var_cvar_vectorized": true,
      "jarque_bera_vectorized": true,

      "time_sliced_metrics": {
        "enabled": true,
        "time_unit": "calendar_year",
        "compute_from_batched_returns": true,
        "store_long_format": true
      }
    }
  },

  "gpu_acceleration": {
    "enabled": true,
    "library": "cupy",
    "fallback_to_cpu": true,

    "use_for": [
      "batch_portfolio_returns_matrix_multiply",
      "batch_cumprod_running_max_for_drawdown",
      "batch_percentiles_for_var_cvar",
      "batch_mean_std_skew_kurtosis"
    ],

    "do_not_use_gpu_for": [
      "small_matrix_inverse_n<=10",
      "cvxpy_solver"
    ],

    "memory_management": {
      "clear_cache_periodically": true,
      "clear_every_n_portfolios": 20000
    }
  },

  "parallelization": {
    "enabled": true,
    "strategy": "parallelize_stage_A_over_asset_sets_then_stage_C_over_metric_blocks",
    "n_jobs": "auto",

    "important_note": "Do NOT rely on in-memory BLCache inside multiprocessing workers. Use precompute_registry persisted artifacts to share work across processes."
  },

  "outputs": {
    "optimal_portfolios": "results/classical_optimization/bl_optimal_weights.parquet",
    "posterior_returns": "results/classical_optimization/bl_posterior_returns.parquet",
    "posterior_covariance": "results/classical_optimization/bl_posterior_covariance.parquet",
    "portfolio_daily_returns_matrix": "results/classical_optimization/bl_portfolio_daily_returns.npy",
    "metrics_table": "results/classical_optimization/bl_metrics.parquet",
    "time_sliced_metrics": "results/classical_optimization/bl_time_sliced_metrics.parquet",
    "metrics_schema_json": "results/classical_optimization/bl_metrics_schema.json",
    "summary_report": "results/classical_optimization/bl_result_summary.md",
    "runtime_profile": "results/classical_optimization/bl_runtime_profile.json"
  },

  "cursor_implementation_tasks": [
    {
      "file": "main.py",
      "changes": [
        "Add Stage A: build unique asset sets from baseline_portfolios; assign each portfolio_id -> asset_set_id.",
        "Precompute per asset_set: cov_matrix, prior_returns(pi), market_weights, parsed views(P,Q,Omega), posterior(mu,cov), optimal weights; persist artifacts in precompute_registry paths.",
        "Replace per-portfolio BL computations with lookup of precomputed values by asset_set_id.",
        "Build full-universe weight matrix W (10 x N) by placing subset weights in the correct asset columns and zeros elsewhere; persist W to .npy.",
        "Compute portfolio returns for all portfolios in batch: R(Tx10) @ W(10xN). If GPU enabled and available, use cupy; else numpy.",
        "Compute metrics in batch from the returns matrix; keep exact formulas (no approximations).",
        "Compute time-sliced metrics from the batched matrix by grouping indices by year; output long-form parquet (portfolio_id, year, metric...).",
        "Write runtime_profile.json with stage timings and GPU info."
      ]
    },
    {
      "file": "black_litterman_optimizer.py",
      "changes": [
        "Add helper to compute optimal weights for a given asset_set without rebuilding CVXPY problems repeatedly.",
        "Enforce closed_form when constraints allow; else reuse parameterized CVXPY problem per asset_set.",
        "Expose small-matrix ops as numpy; do not route inversions to GPU for n<=10."
      ]
    },
    {
      "file": "gpu_acceleration.py",
      "changes": [
        "Add GPU-accelerated batch primitives: matmul for (T x 10) @ (10 x N), cumprod, running_max along axis, percentiles, mean/std.",
        "Keep safe CPU fallback if cupy not available."
      ]
    },
    {
      "file": "cache.py",
      "changes": [
        "Add Disk-backed cache or a PrecomputeRegistry helper: save/load artifacts by asset_set_id and views_hash.",
        "Ensure deterministic keys and metadata for reproducibility."
      ]
    },
    {
      "file": "metrics.py",
      "changes": [
        "Add vectorized/batch metrics entrypoints that accept a returns matrix (T x N).",
        "Implement max_drawdown vectorized using cumulative product and running max along axis.",
        "Implement VaR/CVaR using vectorized percentiles along axis.",
        "Keep per-portfolio versions for debugging parity checks."
      ]
    },
    {
      "file": "time_sliced_metrics.py",
      "changes": [
        "Add batch time-slicing version operating on returns matrix, grouped by calendar year.",
        "Output long-form rows: portfolio_id, period, yearly_return, sharpe, sortino, max_drawdown, var, cvar, etc."
      ]
    }
  ]
}
